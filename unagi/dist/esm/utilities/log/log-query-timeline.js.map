{
  "version": 3,
  "sources": ["../../../../src/utilities/log/log-query-timeline.ts"],
  "sourcesContent": ["import { gray, green, red, yellow } from 'kolorist'\n\nimport { UnagiRequest } from '../../foundation/UnagiRequest/UnagiRequest.server.js'\nimport { QueryKey } from '../../types.js'\nimport { hashKey } from '../hash.js'\nimport { getTime } from '../timing.js'\nimport { RenderType, getLoggerWithContext } from './log.js'\nimport { findQueryName, parseUrl } from './utils.js'\n\nexport type TimingType = 'requested' | 'resolved' | 'rendered' | 'preload'\n\nexport type QueryTiming = {\n  name: string\n  timingType: TimingType\n  timestamp: number\n  duration?: number\n}\n\nconst color = gray\nconst TIMING_MAPPING = {\n  requested: 'Requested',\n  rendered: 'Rendered',\n  resolved: 'Resolved',\n  preload: 'Preload',\n}\n\nexport function collectQueryTimings(\n  request: UnagiRequest,\n  queryKey: QueryKey,\n  timingType: TimingType,\n  duration?: number\n) {\n  const hashedKey = hashKey(queryKey)\n  request.ctx.queryTimings.push({\n    name: findQueryName(hashedKey),\n    timingType,\n    timestamp: getTime(),\n    duration,\n  })\n}\n\nexport function logQueryTimings(type: RenderType, request: UnagiRequest) {\n  const log = getLoggerWithContext(request)\n\n  if (!__UNAGI_DEV__ && !log.options().showQueryTiming) {\n    return\n  }\n\n  const previouslyLoadedRequest = request.previouslyLoadedRequest()\n\n  let logMessage = color(`\u250C\u2500\u2500 Query timings for ${parseUrl(type, request.url)}`)\n\n  let firstSuspenseWaterfallQueryName = ''\n\n  const queryList = request.ctx.queryTimings\n  if (queryList.length > 0) {\n    const requestStartTime = request.time\n    const detectSuspenseWaterfall: Record<string, boolean> = {}\n    const detectMultipleDataLoad: Record<string, number> = {}\n    const preloadedQueries: Set<string> = new Set()\n    let suspenseWaterfallDetectedCount = 0\n\n    queryList.forEach((query: QueryTiming, index: number) => {\n      if (query.timingType === 'preload') preloadedQueries.add(query.name)\n\n      if (query.timingType === 'requested' || query.timingType === 'preload') {\n        detectSuspenseWaterfall[query.name] = true\n      } else if (query.timingType === 'rendered') {\n        delete detectSuspenseWaterfall[query.name]\n      } else if (query.timingType === 'resolved') {\n        detectMultipleDataLoad[query.name] = detectMultipleDataLoad[query.name]\n          ? detectMultipleDataLoad[query.name] + 1\n          : 1\n      }\n\n      const loadColor = query.timingType === 'preload' ? green : color\n      const duration = query.duration\n\n      logMessage += color(\n        `\\n\u2502 ${`${(query.timestamp - requestStartTime).toFixed(2)}ms`.padEnd(10)} ${loadColor(\n          TIMING_MAPPING[query.timingType].padEnd(10)\n        )} ${query.name}${\n          query.timingType === 'resolved' ? ` (Took ${duration?.toFixed(2)}ms)` : ''\n        }`\n      )\n\n      // SSR + RSC render path generates 2 `load` and `render` for each query\n      // We want to avoid falsely identifying a suspense waterfall near the end\n      // of the query list\n      //\n      // The (index + 4) is detecting that near the end of list.\n      // A complete set of events for a given query is 4 entries\n      // \u2502 (639.62ms)  Requested  Localization\n      // \u2502 (993.33ms)  Resolved   Localization (Took 353.66ms)\n      // \u2502 (993.96ms)  Requested  Localization      <-- second time React tries to load\n      // \u2502 (994.03ms)  Rendered   Localization\n      //\n      // so the end of list index range is 3 (one less from a set entry) + 1 (zero index)\n      if (\n        queryList.length >= index + 4 &&\n        Object.keys(detectSuspenseWaterfall).length === 0 &&\n        !preloadedQueries.has(query.name) &&\n        previouslyLoadedRequest\n      ) {\n        // Store the first suspense waterfall query name to display in the summary console output\n        if (!firstSuspenseWaterfallQueryName) firstSuspenseWaterfallQueryName = query.name\n\n        suspenseWaterfallDetectedCount++\n        const warningColor = suspenseWaterfallDetectedCount === 1 ? yellow : red\n        logMessage += `\\n${color(`\u2502 `)}${warningColor(`Suspense waterfall detected`)}`\n      }\n    })\n\n    const unusedQueries = Object.keys(detectSuspenseWaterfall)\n    if (unusedQueries.length > 0) {\n      unusedQueries.forEach((queryName: string) => {\n        logMessage += `\\n${color(`\u2502 `)}${yellow(`Unused query detected: ${queryName}`)}`\n      })\n    }\n\n    Object.keys(detectMultipleDataLoad).forEach((queryName: string) => {\n      const count = detectMultipleDataLoad[queryName]\n      if (count > 1) {\n        logMessage += `\\n${color(`\u2502 `)}${yellow(`Multiple data loads detected: ${queryName}`)}`\n      }\n    })\n  }\n\n  logMessage += '\\n' + color('\u2514\u2500\u2500')\n\n  if (log.options().showQueryTiming) {\n    log.debug(logMessage)\n  } else if (firstSuspenseWaterfallQueryName) {\n    log.debug(yellow('Suspense waterfall detected on query: ' + firstSuspenseWaterfallQueryName))\n    log.debug(\n      '  Add the `showQueryTiming` property to your Unagi configuration to see more information:'\n    )\n    log.debug('  https://shopify.dev/custom-storefronts/unagi/framework/unagi-config#logger')\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
