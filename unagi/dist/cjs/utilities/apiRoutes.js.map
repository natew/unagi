{
  "version": 3,
  "sources": ["../../../src/utilities/apiRoutes.ts"],
  "sourcesContent": ["import { RSC_PATHNAME } from '../constants.js'\nimport type { SessionApi, SessionStorageAdapter } from '../foundation/session/session-types.js'\nimport { emptySessionImplementation } from '../foundation/session/session.js'\nimport type { UnagiRequest } from '../foundation/UnagiRequest/UnagiRequest.server.js'\nimport { ImportGlobEagerOutput, ResolvedUnagiConfig, ResolvedUnagiRoutes } from '../types.js'\nimport { getLoggerWithContext, logServerResponse } from '../utilities/log/index.js'\nimport { matchPath } from './matchPath.js'\n\nlet memoizedApiRoutes: Array<UnagiApiRoute> = []\nlet memoizedRawRoutes: ImportGlobEagerOutput = {}\n\ntype RouteParams = Record<string, string>\nexport type RequestOptions = {\n  params: RouteParams\n  session: SessionApi | null\n  unagiConfig: ResolvedUnagiConfig\n}\nexport type ResourceGetter = (\n  request: UnagiRequest,\n  requestOptions: RequestOptions\n) => Promise<Response | Object | String>\n\ninterface UnagiApiRoute {\n  path: string\n  resource: ResourceGetter\n  hasServerComponent: boolean\n}\n\nexport type ApiRouteMatch = {\n  resource: ResourceGetter\n  hasServerComponent: boolean\n  params: RouteParams\n}\n\nexport function extractPathFromRoutesKey(routesKey: string, dirPrefix: string | RegExp) {\n  let path = routesKey\n    .replace(dirPrefix, '')\n    .replace(/\\.server\\.(t|j)sx?$/, '')\n    /**\n     * Replace /index with /\n     */\n    .replace(/\\/index$/i, '/')\n    /**\n     * Only lowercase the first letter. This allows the developer to use camelCase\n     * dynamic paths while ensuring their standard routes are normalized to lowercase.\n     */\n    .replace(/\\b[A-Z]/, (firstLetter) => firstLetter.toLowerCase())\n    /**\n     * Convert /[handle].jsx and /[...handle].jsx to /:handle.jsx for react-router-dom\n     */\n    .replace(/\\[(?:[.]{3})?(\\w+?)\\]/g, (_match, param: string) => `:${param}`)\n\n  if (path.endsWith('/') && path !== '/') {\n    path = path.substring(0, path.length - 1)\n  }\n\n  return path\n}\n\nexport function getApiRoutes({\n  files: routes,\n  basePath: topLevelPath = '',\n  dirPrefix = '',\n}: Partial<ResolvedUnagiRoutes>): Array<UnagiApiRoute> {\n  if (!routes || memoizedRawRoutes === routes) return memoizedApiRoutes\n\n  const topLevelPrefix = topLevelPath.replace('*', '').replace(/\\/$/, '')\n\n  const keys = Object.keys(routes)\n\n  const apiRoutes = keys\n    .filter((key) => routes[key].api)\n    .map((key) => {\n      const path = extractPathFromRoutesKey(key, dirPrefix)\n\n      /**\n       * Catch-all routes [...handle].jsx don't need an exact match\n       * https://reactrouter.com/core/api/Route/exact-bool\n       */\n      const exact = !/\\[(?:[.]{3})(\\w+?)\\]/.test(key)\n\n      return {\n        path: topLevelPrefix + path,\n        resource: routes[key].api,\n        hasServerComponent: !!routes[key].default,\n        exact,\n      }\n    })\n\n  memoizedApiRoutes = [\n    ...apiRoutes.filter((route) => !route.path.includes(':')),\n    ...apiRoutes.filter((route) => route.path.includes(':')),\n  ]\n\n  memoizedRawRoutes = routes\n\n  return memoizedApiRoutes\n}\n\nexport function getApiRouteFromURL(url: URL, routes: Array<UnagiApiRoute>): ApiRouteMatch | null {\n  let foundRoute, foundRouteDetails\n\n  for (let i = 0; i < routes.length; i++) {\n    foundRouteDetails = matchPath(url.pathname, routes[i])\n\n    if (foundRouteDetails) {\n      foundRoute = routes[i]\n      break\n    }\n  }\n\n  if (!foundRoute) return null\n\n  return {\n    resource: foundRoute.resource,\n    params: foundRouteDetails.params,\n    hasServerComponent: foundRoute.hasServerComponent,\n  }\n}\n\nexport async function renderApiRoute(\n  request: UnagiRequest,\n  route: ApiRouteMatch,\n  unagiConfig: ResolvedUnagiConfig,\n  {\n    session,\n    suppressLog,\n  }: {\n    session?: SessionStorageAdapter\n    suppressLog?: boolean\n  }\n): Promise<Response | Request> {\n  let response: any\n  const log = getLoggerWithContext(request)\n  let cookieToSet = ''\n\n  try {\n    response = await route.resource(request, {\n      params: route.params,\n      unagiConfig,\n      session: session\n        ? {\n            async get() {\n              return session.get(request)\n            },\n            async set(key: string, value: string) {\n              const data = await session.get(request)\n              data[key] = value\n              cookieToSet = await session.set(request, data)\n            },\n            async destroy() {\n              cookieToSet = await session.destroy(request)\n            },\n          }\n        : emptySessionImplementation(log),\n    })\n\n    if (!(response instanceof Response || response instanceof Request)) {\n      if (typeof response === 'string' || response instanceof String) {\n        response = new Response(response as string)\n      } else if (typeof response === 'object') {\n        response = new Response(JSON.stringify(response), {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        })\n      }\n    }\n\n    if (!response) {\n      response = new Response(null)\n    }\n\n    if (cookieToSet) {\n      response.headers.set('Set-Cookie', cookieToSet)\n    }\n  } catch (e) {\n    log.error(e)\n    response = new Response('Error processing: ' + request.url, {\n      status: 500,\n    })\n  }\n\n  if (!suppressLog) {\n    logServerResponse('api', request as UnagiRequest, (response as Response).status ?? 200)\n  }\n\n  if (response instanceof Request) {\n    const url = new URL(request.url)\n    const newUrl = new URL(response.url, url)\n\n    if (request.headers.get('Unagi-Client') === 'Form-Action') {\n      response.headers.set('Unagi-RSC-Pathname', newUrl.pathname + newUrl.search)\n      return new Request(getRscUrl(url, newUrl), {\n        headers: response.headers,\n      })\n    } else {\n      // This request was made by a native form presumably because the client components had yet to hydrate,\n      // Because of this, we need to redirect instead of just rendering the response.\n      // Doing so prevents odd refresh / back behavior. The redirect response also should *never* be cached.\n      response.headers.set('Location', newUrl.href)\n      response.headers.set('Cache-Control', 'no-store')\n\n      return new Response(null, {\n        status: 303,\n        headers: response.headers,\n      })\n    }\n  }\n\n  return response\n}\n\nfunction getRscUrl(currentUrl: URL, newUrl: URL) {\n  const rscUrl = new URL(RSC_PATHNAME, currentUrl)\n  const searchParams = new URLSearchParams({\n    state: JSON.stringify({\n      pathname: newUrl.pathname,\n      search: newUrl.search,\n    }),\n  })\n  rscUrl.search = searchParams.toString()\n  return rscUrl.toString()\n}\n"],
  "mappings": "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",
  "names": []
}
