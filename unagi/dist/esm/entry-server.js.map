{
  "version": 3,
  "sources": ["../../src/entry-server.tsx"],
  "sourcesContent": ["import type { ServerResponse } from 'http'\nimport type { PassThrough as PassThroughType } from 'stream'\n\nimport React, { Suspense } from 'react'\nimport { splitCookiesString } from 'set-cookie-parser'\n\nimport { getBuiltInRoute } from './foundation/BuiltInRoutes/BuiltInRoutes.js'\nimport {\n  deleteItemFromCache,\n  getItemFromCache,\n  isStale,\n  setItemInCache,\n} from './foundation/Cache/cache.js'\nimport { CacheShort, NO_STORE } from './foundation/Cache/strategies/index.js'\nimport { DevTools } from './foundation/DevTools/DevTools.server.js'\nimport { Html, applyHtmlHead } from './foundation/Html/Html.js'\nimport { getCache, setCache } from './foundation/runtime.js'\nimport { ServerPropsProvider } from './foundation/ServerPropsProvider/index.js'\nimport {\n  ServerRequestProvider,\n  preloadRequestCacheData,\n} from './foundation/ServerRequestProvider/index.js'\nimport { getSyncSessionApi } from './foundation/session/session.js'\nimport { UnagiRequest } from './foundation/UnagiRequest/UnagiRequest.server.js'\nimport { UnagiResponse } from './foundation/UnagiResponse/UnagiResponse.server.js'\nimport type { RequestHandlerOptions } from './shared-types.js'\nimport {\n  bufferReadableStream,\n  createFromReadableStream,\n  rscRenderToReadableStream,\n  ssrRenderToPipeableStream,\n  ssrRenderToReadableStream,\n} from './streaming.server.js'\nimport type {\n  AssembleHtmlParams,\n  RequestHandler,\n  ResolvedUnagiConfig,\n  ResolvedUnagiRoutes,\n  RunRscParams,\n  RunSsrParams,\n} from './types.js'\nimport { getApiRouteFromURL, getApiRoutes, renderApiRoute } from './utilities/apiRoutes.js'\nimport { isBotUA } from './utilities/bot-ua.js'\nimport { getErrorMarkup } from './utilities/error.js'\nimport { htmlEncode } from './utilities/htmlEncoding.js'\nimport {\n  Logger,\n  RenderType,\n  getLoggerWithContext,\n  logCacheControlHeaders,\n  logQueryTimings,\n  logServerResponse,\n  setLogger,\n} from './utilities/log/index.js'\nimport { parseJSON } from './utilities/parse.js'\nimport { stripScriptsFromTemplate } from './utilities/template.js'\n\ndeclare global {\n  // This is provided by a Vite plugin\n  // and will trigger tree-shaking.\n  // eslint-disable-next-line no-var\n  var __UNAGI_WORKER__: boolean\n}\n\nconst DOCTYPE = '<!DOCTYPE html>'\nconst CONTENT_TYPE = 'Content-Type'\nconst HTML_CONTENT_TYPE = 'text/html; charset=UTF-8'\n\nexport const renderUnagi = (App: any) => {\n  const handleRequest: RequestHandler = async function (rawRequest, options) {\n    const { cache, context, buyerIpHeader, headers } = options\n\n    const request = new UnagiRequest(rawRequest)\n    const url = new URL(request.url)\n\n    let sessionApi = options.sessionApi\n\n    const { default: inlineUnagiConfig } = await import(\n      // @ts-ignore\n      'virtual__unagi.config.ts'\n    )\n\n    const { default: unagiRoutes } = await import(\n      // @ts-ignore\n      'virtual__unagi-routes.server.jsx'\n    )\n\n    const unagiConfig: ResolvedUnagiConfig = {\n      ...inlineUnagiConfig,\n      routes: unagiRoutes,\n    }\n\n    request.ctx.unagiConfig = unagiConfig\n    request.ctx.buyerIpHeader = buyerIpHeader\n\n    setLogger(unagiConfig.logger)\n    const log = getLoggerWithContext(request)\n\n    const response = new UnagiResponse(null, {\n      headers: headers || {},\n    })\n\n    if (unagiConfig.poweredByHeader ?? true) {\n      // If undefined in the config, then always show the header\n      response.headers.set('powered-by', 'Tamagui-Unagi')\n    }\n\n    sessionApi ??= unagiConfig.session?.(log)\n\n    request.ctx.session = getSyncSessionApi(request, response, log, sessionApi)\n\n    /**\n     * Inject the cache & context into the module loader so we can pull it out for subrequests.\n     */\n    request.ctx.runtime = context\n\n    setCache(cache)\n\n    const builtInRouteResource = getBuiltInRoute(url)\n\n    if (builtInRouteResource) {\n      const apiResponse = await renderApiRoute(\n        request,\n        {\n          resource: builtInRouteResource,\n          params: {},\n          hasServerComponent: false,\n        },\n        unagiConfig,\n        {\n          session: sessionApi,\n          suppressLog: true,\n        }\n      )\n\n      return apiResponse instanceof Request\n        ? handleRequest(apiResponse, {\n            ...options,\n            sessionApi,\n            headers: apiResponse.headers,\n          })\n        : apiResponse\n    }\n\n    // Check if we have cached response\n    if (cache) {\n      const cachedResponse = await getItemFromCache(request.cacheKey())\n      if (cachedResponse) {\n        if (isStale(request, cachedResponse)) {\n          const lockCacheKey = request.cacheKey(true)\n          const staleWhileRevalidatePromise = getItemFromCache(lockCacheKey).then(\n            async (lockExists: Response | undefined) => {\n              if (lockExists) return\n              try {\n                // Don't stream when creating a response for cache\n                response.doNotStream()\n\n                await setItemInCache(\n                  lockCacheKey,\n                  new Response(null),\n                  CacheShort({\n                    maxAge: 10,\n                  })\n                )\n\n                await processRequest(\n                  handleRequest,\n                  App,\n                  url,\n                  request,\n                  sessionApi,\n                  options,\n                  response,\n                  unagiConfig,\n                  true\n                )\n              } catch (e: any) {\n                log.error('Cache revalidate error', e)\n              }\n            }\n          )\n\n          // Asynchronously wait for it in workers\n          request.ctx.runtime?.waitUntil(staleWhileRevalidatePromise)\n        }\n\n        return cachedResponse\n      }\n    }\n\n    return processRequest(\n      handleRequest,\n      App,\n      url,\n      request,\n      sessionApi,\n      options,\n      response,\n      unagiConfig\n    )\n  }\n\n  if (__UNAGI_WORKER__) return handleRequest\n\n  return ((rawRequest, options) =>\n    handleFetchResponseInNode(\n      handleRequest(rawRequest, options),\n      options.streamableResponse\n    )) as RequestHandler\n}\n\nasync function processRequest(\n  handleRequest: RequestHandler,\n  App: any,\n  url: URL,\n  request: UnagiRequest,\n  sessionApi: any,\n  options: RequestHandlerOptions,\n  response: UnagiResponse,\n  unagiConfig: ResolvedUnagiConfig,\n  revalidate = false\n) {\n  const { dev, nonce, indexTemplate, streamableResponse: nodeResponse } = options\n\n  const log = getLoggerWithContext(request)\n  const isRSCRequest = request.isRscRequest()\n  const apiRoute = !isRSCRequest && getApiRoute(url, unagiConfig.routes)\n\n  // The API Route might have a default export, making it also a server component\n  // If it does, only render the API route if the request method is GET\n  if (apiRoute && (!apiRoute.hasServerComponent || request.method !== 'GET')) {\n    const apiResponse = await renderApiRoute(request, apiRoute, unagiConfig, {\n      session: sessionApi,\n    })\n\n    return apiResponse instanceof Request\n      ? handleRequest(apiResponse, {\n          ...options,\n          sessionApi,\n          headers: apiResponse.headers,\n        })\n      : apiResponse\n  }\n\n  const state: Record<string, any> = isRSCRequest\n    ? parseJSON(decodeURIComponent(url.searchParams.get('state') || '{}'))\n    : {\n        pathname: decodeURIComponent(url.pathname),\n        search: decodeURIComponent(url.search),\n      }\n\n  const rsc = runRSC({ App, state, log, request, response })\n\n  if (isRSCRequest) {\n    const buffered = await bufferReadableStream(rsc.readable.getReader())\n    postRequestTasks('rsc', 200, request, response)\n    cacheResponse(response, request, [buffered], revalidate)\n\n    return new Response(buffered, {\n      headers: response.headers,\n    })\n  }\n\n  if (isBotUA(url, request.headers.get('user-agent'))) {\n    response.doNotStream()\n  }\n\n  return runSSR({\n    log,\n    dev,\n    rsc,\n    nonce,\n    state,\n    request,\n    response,\n    nodeResponse,\n    template: await getTemplate(indexTemplate, url),\n    revalidate,\n  })\n}\n\nasync function getTemplate(\n  indexTemplate: string | ((url: string) => Promise<string | { default: string }>),\n  url: URL\n) {\n  let template =\n    typeof indexTemplate === 'function' ? await indexTemplate(url.toString()) : indexTemplate\n\n  if (template && typeof template !== 'string') {\n    template = template.default\n  }\n\n  return template\n}\n\nfunction getApiRoute(url: URL, routes: ResolvedUnagiRoutes) {\n  const apiRoutes = getApiRoutes(routes)\n  return getApiRouteFromURL(url, apiRoutes)\n}\n\nfunction assembleHtml({ ssrHtml, rscPayload, request, template }: AssembleHtmlParams) {\n  let html = applyHtmlHead(ssrHtml, request.ctx.head, template)\n\n  if (rscPayload) {\n    html = html.replace(\n      '</body>',\n      // This must be a function to avoid replacing\n      // special patterns like `$1` in `String.replace`.\n      () => flightContainer(rscPayload) + '</body>'\n    )\n  }\n\n  return html\n}\n\n/**\n * Run the SSR/Fizz part of the App. If streaming is disabled,\n * this buffers the output and applies SEO enhancements.\n */\nasync function runSSR({\n  rsc,\n  state,\n  request,\n  response,\n  nodeResponse,\n  template,\n  nonce,\n  dev,\n  log,\n  revalidate,\n}: RunSsrParams) {\n  let ssrDidError: Error | undefined\n  const didError = () => rsc.didError() ?? ssrDidError\n\n  const [rscReadableForFizz, rscReadableForFlight] = rsc.readable.tee()\n  const rscResponse = createFromReadableStream(rscReadableForFizz)\n  const RscConsumer = () => rscResponse.readRoot()\n\n  const { noScriptTemplate, bootstrapScripts, bootstrapModules } =\n    stripScriptsFromTemplate(template)\n\n  const AppSSR = (\n    <Html\n      template={response.canStream() ? noScriptTemplate : template}\n      unagiConfig={request.ctx.unagiConfig!}\n    >\n      <ServerRequestProvider request={request}>\n        <ServerPropsProvider\n          initialServerProps={state as any}\n          setServerPropsForRsc={() => {}}\n          setRscResponseFromApiRoute={() => {}}\n        >\n          <Suspense fallback={null}>\n            <RscConsumer />\n          </Suspense>\n        </ServerPropsProvider>\n      </ServerRequestProvider>\n    </Html>\n  )\n\n  log.trace('start ssr')\n\n  const rscReadable = response.canStream()\n    ? new ReadableStream({\n        start(controller) {\n          log.trace('rsc start chunks')\n          const encoder = new TextEncoder()\n          bufferReadableStream(rscReadableForFlight.getReader(), (chunk) => {\n            const metaTag = flightContainer(chunk)\n            controller.enqueue(encoder.encode(metaTag))\n          }).then(() => {\n            log.trace('rsc finish chunks')\n            return controller.close()\n          })\n        },\n      })\n    : rscReadableForFlight\n\n  if (__UNAGI_WORKER__) {\n    const encoder = new TextEncoder()\n    const transform = new TransformStream()\n    const writable = transform.writable.getWriter()\n    const responseOptions = {} as ResponseOptions\n    const savedChunks = tagOnWrite(writable)\n\n    let ssrReadable: Awaited<ReturnType<typeof ssrRenderToReadableStream>>\n\n    try {\n      ssrReadable = await ssrRenderToReadableStream(AppSSR, {\n        nonce,\n        bootstrapScripts,\n        bootstrapModules,\n        onError(error) {\n          ssrDidError = error as Error\n\n          if (dev && !writable.closed && !!responseOptions.status) {\n            writable.write(getErrorMarkup(error as Error))\n          }\n\n          log.error(error)\n        },\n      })\n    } catch (error: unknown) {\n      log.error(error)\n\n      return new Response(template + (dev ? getErrorMarkup(error as Error) : ''), {\n        status: 500,\n        headers: { [CONTENT_TYPE]: HTML_CONTENT_TYPE },\n      })\n    }\n\n    if (response.canStream()) log.trace('worker ready to stream')\n    ssrReadable.allReady.then(() => log.trace('worker complete ssr'))\n\n    const prepareForStreaming = () => {\n      Object.assign(responseOptions, getResponseOptions(response, didError()))\n\n      if (responseOptions.status >= 400) {\n        responseOptions.headers.set('cache-control', 'no-store')\n      } else {\n        /**\n         * TODO: This assumes `response.cache()` has been called _before_ any\n         * queries which might be caught behind Suspense. Clarify this or add\n         * additional checks downstream?\n         */\n        /**\n         * TODO: Also add `Vary` headers for `accept-language` and any other keys\n         * we want to shard our full-page cache for all Unagi storefronts.\n         */\n        responseOptions.headers.set('cache-control', response.cacheControlHeader)\n      }\n\n      if (isRedirect(responseOptions)) {\n        return false\n      }\n\n      responseOptions.headers.set(CONTENT_TYPE, HTML_CONTENT_TYPE)\n      writable.write(encoder.encode(DOCTYPE))\n\n      const error = didError()\n      if (error) {\n        // This error was delayed until the headers were properly sent.\n        writable.write(encoder.encode(dev ? getErrorMarkup(error) : template))\n      }\n\n      return true\n    }\n\n    const shouldFlushBody = response.canStream()\n      ? prepareForStreaming()\n      : await ssrReadable.allReady.then(prepareForStreaming)\n\n    if (shouldFlushBody) {\n      let bufferedSsr = ''\n      let isPendingSsrWrite = false\n\n      const writingSSR = bufferReadableStream(\n        ssrReadable.getReader(),\n        response.canStream()\n          ? (chunk) => {\n              bufferedSsr += chunk\n\n              if (!isPendingSsrWrite) {\n                isPendingSsrWrite = true\n                setTimeout(() => {\n                  isPendingSsrWrite = false\n                  // React can write fractional chunks synchronously.\n                  // This timeout ensures we only write full HTML tags\n                  // in order to allow RSC writing concurrently.\n                  if (bufferedSsr) {\n                    writable.write(encoder.encode(bufferedSsr))\n                    bufferedSsr = ''\n                  }\n                }, 0)\n              }\n            }\n          : undefined\n      )\n\n      const writingRSC = bufferReadableStream(\n        rscReadable.getReader(),\n        response.canStream() ? (scriptTag) => writable.write(encoder.encode(scriptTag)) : undefined\n      )\n\n      Promise.all([writingSSR, writingRSC]).then(([ssrHtml, rscPayload]) => {\n        if (!response.canStream()) {\n          const html = assembleHtml({ ssrHtml, rscPayload, request, template })\n          writable.write(encoder.encode(html))\n        }\n\n        // Last SSR write might be pending, delay closing the writable one tick\n        setTimeout(() => {\n          writable.close()\n          postRequestTasks('str', responseOptions.status, request, response)\n          response.status = responseOptions.status\n          cacheResponse(response, request, savedChunks, revalidate)\n        }, 0)\n      })\n    } else {\n      // Redirects do not write body\n      writable.close()\n      postRequestTasks('str', responseOptions.status, request, response)\n    }\n\n    if (response.canStream()) {\n      return new Response(transform.readable, responseOptions)\n    }\n\n    const bufferedBody = await bufferReadableStream(transform.readable.getReader())\n\n    return new Response(bufferedBody, responseOptions)\n  } else if (nodeResponse) {\n    const savedChunks = tagOnWrite(nodeResponse)\n\n    nodeResponse.on('finish', () => {\n      response.status = nodeResponse.statusCode\n      cacheResponse(response, request, savedChunks, revalidate)\n    })\n\n    const { pipe } = ssrRenderToPipeableStream(AppSSR, {\n      nonce,\n      bootstrapScripts,\n      bootstrapModules,\n      onShellReady() {\n        log.trace('node ready to stream')\n\n        /**\n         * TODO: This assumes `response.cache()` has been called _before_ any\n         * queries which might be caught behind Suspense. Clarify this or add\n         * additional checks downstream?\n         */\n        writeHeadToNodeResponse(nodeResponse, response, log, didError())\n\n        if (isRedirect(nodeResponse)) {\n          // Return redirects early without further rendering/streaming\n          return nodeResponse.end()\n        }\n\n        if (!response.canStream()) return\n\n        startWritingToNodeResponse(nodeResponse, dev ? didError() : undefined)\n\n        setTimeout(() => {\n          log.trace('node pipe response')\n          if (!nodeResponse.writableEnded) pipe(nodeResponse)\n        }, 0)\n\n        bufferReadableStream(rscReadable.getReader(), (chunk) => {\n          log.trace('rsc chunk')\n          if (!nodeResponse.writableEnded) nodeResponse.write(chunk)\n        })\n      },\n      async onAllReady() {\n        log.trace('node complete ssr')\n\n        if (!revalidate && (response.canStream() || nodeResponse.writableEnded)) {\n          postRequestTasks('str', nodeResponse.statusCode, request, response)\n          return\n        }\n\n        writeHeadToNodeResponse(nodeResponse, response, log, didError())\n\n        if (isRedirect(nodeResponse)) {\n          // Redirects found after any async code\n          return nodeResponse.end()\n        }\n\n        const bufferedResponse = await createNodeWriter()\n        const bufferedRscPromise = bufferReadableStream(rscReadable.getReader())\n\n        let ssrHtml = ''\n        bufferedResponse.on('data', (chunk) => (ssrHtml += chunk.toString()))\n        bufferedResponse.once('error', (error) => (ssrDidError = error))\n        bufferedResponse.once('end', async () => {\n          const rscPayload = await bufferedRscPromise\n\n          const error = didError()\n          startWritingToNodeResponse(nodeResponse, dev ? error : undefined)\n\n          let html = template\n\n          if (!error) {\n            html = assembleHtml({ ssrHtml, rscPayload, request, template })\n            postRequestTasks('ssr', nodeResponse.statusCode, request, response)\n          }\n\n          if (!nodeResponse.writableEnded) {\n            nodeResponse.write(html)\n            nodeResponse.end()\n          }\n        })\n\n        pipe(bufferedResponse)\n      },\n      onShellError(error: any) {\n        log.error(error)\n\n        if (!nodeResponse.writableEnded) {\n          writeHeadToNodeResponse(nodeResponse, response, log, error)\n          startWritingToNodeResponse(nodeResponse, dev ? error : undefined)\n\n          nodeResponse.write(template)\n          nodeResponse.end()\n        }\n      },\n      onError(error: any) {\n        if (error.message?.includes('stream closed early')) {\n          // This seems to happen when Fizz is still streaming\n          // but nodeResponse has been closed by the browser.\n          // This is common in tests and during development\n          // due to frequent page refresh.\n          return\n        }\n\n        ssrDidError = error\n\n        if (dev && nodeResponse.headersSent && !nodeResponse.writableEnded) {\n          // Calling write would flush headers automatically.\n          // Delay this error until headers are properly sent.\n          nodeResponse.write(getErrorMarkup(error))\n        }\n\n        log.error(error)\n      },\n    })\n  }\n}\n\n/**\n * Run the RSC/Flight part of the App\n */\nfunction runRSC({ App, state, log, request, response }: RunRscParams) {\n  const serverProps = { ...state, request, response, log }\n  request.ctx.router.serverProps = serverProps\n  preloadRequestCacheData(request)\n\n  const AppRSC = (\n    <ServerRequestProvider request={request}>\n      <App {...serverProps} />\n      {/* <Suspense fallback={null}>\n        <Analytics />\n      </Suspense> */}\n      {request.ctx.unagiConfig?.__EXPERIMENTAL__devTools && (\n        <Suspense fallback={null}>\n          <DevTools />\n        </Suspense>\n      )}\n    </ServerRequestProvider>\n  )\n\n  let rscDidError: Error\n  const rscReadable = rscRenderToReadableStream(AppRSC, {\n    onError(e) {\n      rscDidError = e\n      log.error(e)\n    },\n  })\n\n  return { readable: rscReadable, didError: () => rscDidError }\n}\n\nexport default renderUnagi\n\nfunction startWritingToNodeResponse(nodeResponse: ServerResponse, error?: Error) {\n  if (nodeResponse.writableEnded) return\n\n  if (!nodeResponse.headersSent) {\n    nodeResponse.setHeader(CONTENT_TYPE, HTML_CONTENT_TYPE)\n    nodeResponse.write(DOCTYPE)\n  }\n\n  if (error) {\n    // This error was delayed until the headers were properly sent.\n    nodeResponse.write(getErrorMarkup(error))\n  }\n}\n\ntype ResponseOptions = {\n  headers: Headers\n  status: number\n  statusText?: string\n}\n\nfunction getResponseOptions({ headers, status, statusText }: UnagiResponse, error?: Error) {\n  const responseInit = {\n    headers,\n    status: error ? 500 : status,\n  } as ResponseOptions\n\n  if (!error && statusText) {\n    responseInit.statusText = statusText\n  }\n\n  return responseInit\n}\n\nfunction writeHeadToNodeResponse(\n  nodeResponse: ServerResponse,\n  componentResponse: UnagiResponse,\n  log: Logger,\n  error?: Error\n) {\n  if (nodeResponse.headersSent) return\n  log.trace('writeHeadToNodeResponse')\n\n  const { headers, status, statusText } = getResponseOptions(componentResponse, error)\n\n  if (status >= 400) {\n    nodeResponse.setHeader('cache-control', 'no-store')\n  } else {\n    /**\n     * TODO: Also add `Vary` headers for `accept-language` and any other keys\n     * we want to shard our full-page cache for all Unagi storefronts.\n     */\n    nodeResponse.setHeader('cache-control', componentResponse.cacheControlHeader)\n  }\n\n  nodeResponse.statusCode = status\n\n  if (statusText) {\n    nodeResponse.statusMessage = statusText\n  }\n\n  setNodeHeaders(headers, nodeResponse)\n}\n\nfunction isRedirect(response: { status?: number; statusCode?: number }) {\n  const status = response.status ?? response.statusCode ?? 0\n  return status >= 300 && status < 400\n}\n\nasync function createNodeWriter() {\n  // Importing 'stream' directly breaks Vite resolve\n  // when building for workers, even though this code\n  // does not run in a worker. Looks like tree-shaking\n  // kicks in after the import analysis/bundle.\n  const streamImport = __UNAGI_WORKER__ ? '' : 'stream'\n  const { PassThrough } = await import(streamImport)\n  return new PassThrough() as InstanceType<typeof PassThroughType>\n}\n\nfunction flightContainer(chunk: string) {\n  return `<meta data-flight=\"${htmlEncode(chunk)}\" />`\n}\n\nfunction postRequestTasks(\n  type: RenderType,\n  status: number,\n  request: UnagiRequest,\n  response: UnagiResponse\n) {\n  logServerResponse(type, request, status)\n  logCacheControlHeaders(type, request, response)\n  logQueryTimings(type, request)\n  request.savePreloadQueries()\n}\n\n/**\n * Ensure Node.js environments handle the fetch Response correctly.\n */\nfunction handleFetchResponseInNode(\n  fetchResponsePromise: Promise<Response | undefined>,\n  nodeResponse?: ServerResponse\n) {\n  if (nodeResponse) {\n    fetchResponsePromise.then((response) => {\n      if (!response || nodeResponse.writableEnded) return\n\n      setNodeHeaders(response.headers, nodeResponse)\n\n      nodeResponse.statusCode = response.status\n\n      if (response.body) {\n        if (response.body instanceof ReadableStream) {\n          bufferReadableStream(response.body.getReader(), (chunk) => {\n            nodeResponse.write(chunk)\n          }).then(() => nodeResponse.end())\n        } else {\n          nodeResponse.write(response.body)\n          nodeResponse.end()\n        }\n      } else {\n        nodeResponse.end()\n      }\n    })\n  }\n\n  return fetchResponsePromise\n}\n\n/**\n * Convert Headers to outgoing Node.js headers.\n * Specifically, parse set-cookie headers to split them properly as separate\n * `set-cookie` headers rather than a single, combined header.\n */\nfunction setNodeHeaders(headers: Headers, nodeResponse: ServerResponse) {\n  // @ts-ignore\n  for (const [key, value] of headers.entries()) {\n    if (key.toLowerCase() === 'set-cookie') {\n      nodeResponse.setHeader(key, splitCookiesString(value))\n    } else {\n      nodeResponse.setHeader(key, value)\n    }\n  }\n}\n\nfunction tagOnWrite(response: ServerResponse | WritableStreamDefaultWriter<any>) {\n  const originalWrite = response.write\n  const decoder = new TextDecoder()\n  const savedChunks: string[] = []\n\n  response.write = (arg: any) => {\n    if (arg instanceof Uint8Array) {\n      savedChunks.push(decoder.decode(arg))\n    } else {\n      savedChunks.push(arg)\n    }\n    // @ts-ignore\n    return originalWrite.apply(response, [arg])\n  }\n\n  return savedChunks\n}\n\nasync function cacheResponse(\n  response: UnagiResponse,\n  request: UnagiRequest,\n  chunks: string[],\n  revalidate?: Boolean\n) {\n  const cache = getCache()\n\n  /**\n   * Only full page cache on cachable responses where response\n   *\n   * - have content to cache\n   * - have status 200\n   * - does not have no-store on cache-control header\n   * - does not have set-cookie header\n   * - is a GET request\n   * - does not have a session or does not have an active customer access token\n   */\n  if (\n    cache &&\n    chunks.length > 0 &&\n    response.status === 200 &&\n    response.cache().mode !== NO_STORE &&\n    !response.headers.has('Set-Cookie') &&\n    /get/i.test(request.method) &&\n    !sessionHasCustomerAccessToken(request)\n  ) {\n    if (revalidate) {\n      await saveCacheResponse(response, request, chunks)\n    } else {\n      const cachePutPromise = Promise.resolve(true).then(() =>\n        saveCacheResponse(response, request, chunks)\n      )\n      request.ctx.runtime?.waitUntil(cachePutPromise)\n    }\n  }\n}\n\nfunction sessionHasCustomerAccessToken(request: UnagiRequest) {\n  const session = request.ctx.session\n  // Need to wrap this in a try catch because session.get can\n  // throw a promise if it is not ready\n  try {\n    const sessionData = session?.get()\n    return sessionData && sessionData['customerAccessToken']\n  } catch (error) {\n    return false\n  }\n}\n\nasync function saveCacheResponse(response: UnagiResponse, request: UnagiRequest, chunks: string[]) {\n  const cache = getCache()\n\n  if (cache && chunks.length > 0) {\n    const { headers, status, statusText } = getResponseOptions(response)\n\n    headers.set('cache-control', response.cacheControlHeader)\n    const currentHeader = headers.get('Content-Type')\n    if (!currentHeader && !request.isRscRequest()) {\n      headers.set('Content-Type', HTML_CONTENT_TYPE)\n    }\n\n    await setItemInCache(\n      request.cacheKey(),\n      new Response(chunks.join(''), {\n        status,\n        statusText,\n        headers,\n      }),\n      response.cache()\n    )\n    deleteItemFromCache(request.cacheKey(true))\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
