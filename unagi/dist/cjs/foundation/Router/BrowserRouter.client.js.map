{
  "version": 3,
  "sources": ["../../../../src/foundation/Router/BrowserRouter.client.tsx"],
  "sourcesContent": ["import { BrowserHistory, Location, createBrowserHistory } from 'history'\nimport React, {\n  FC,\n  ReactNode,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useState,\n} from 'react'\n\nimport type { LocationServerProps } from '../ServerPropsProvider/ServerPropsProvider.js'\nimport { META_ENV_SSR } from '../ssrInterop.js'\nimport { useInternalServerProps } from '../useServerProps.js'\n\ntype RouterContextValue = {\n  history: BrowserHistory\n  location: Location\n}\n\nexport const RouterContext = createContext<RouterContextValue | undefined>(undefined)\n\nlet isFirstLoad = true\nconst positions: Record<string, number> = {}\n\nexport const BrowserRouter: FC<{\n  history?: BrowserHistory\n  children: ReactNode\n}> = ({ history: pHistory, children }) => {\n  if (META_ENV_SSR) return <>{children}</>\n  /* eslint-disable react-hooks/rules-of-hooks */\n\n  const history = useMemo(() => pHistory || createBrowserHistory(), [pHistory])\n  const [location, setLocation] = useState(history.location)\n  const [scrollNeedsRestoration, setScrollNeedsRestoration] = useState(false)\n\n  const { pending, locationServerProps, setLocationServerProps } = useInternalServerProps()\n\n  useScrollRestoration({\n    location,\n    pending,\n    serverProps: locationServerProps,\n    scrollNeedsRestoration,\n    onFinishNavigating: () => setScrollNeedsRestoration(false),\n  })\n\n  useLayoutEffect(() => {\n    const unlisten = history.listen(({ location: newLocation, action }) => {\n      positions[location.key] = window.scrollY\n\n      setLocationServerProps({\n        pathname: newLocation.pathname,\n        search: newLocation.search,\n      })\n\n      setLocation(newLocation)\n\n      const state = (newLocation.state ?? {}) as Record<string, any>\n\n      /**\n       * \"pop\" navigations, like forward/backward buttons, always restore scroll position\n       * regardless of what the original forward navigation intent was.\n       */\n      const needsScrollRestoration = action === 'POP' || !!state.scroll\n\n      setScrollNeedsRestoration(needsScrollRestoration)\n    })\n\n    return () => unlisten()\n  }, [history, location, setScrollNeedsRestoration, setLocation, setLocationServerProps])\n\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  return (\n    <RouterContext.Provider\n      value={{\n        history,\n        location,\n      }}\n    >\n      {children}\n    </RouterContext.Provider>\n  )\n}\n\nexport function useRouter() {\n  if (META_ENV_SSR) return { location: {}, history: {} } as RouterContextValue\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const router = useContext(RouterContext)\n  if (router) return router\n\n  throw new Error('Router hooks and <Link> component must be used within a <Router> component')\n}\n\nexport function useLocation() {\n  return useRouter().location\n}\n\n/**\n * Run a callback before browser unload.\n */\nfunction useBeforeUnload(callback: () => any): void {\n  React.useEffect(() => {\n    window.addEventListener('beforeunload', callback)\n    return () => {\n      window.removeEventListener('beforeunload', callback)\n    }\n  }, [callback])\n}\n\nfunction useScrollRestoration({\n  location,\n  pending,\n  serverProps,\n  scrollNeedsRestoration,\n  onFinishNavigating,\n}: {\n  location: Location\n  pending: boolean\n  serverProps: LocationServerProps\n  scrollNeedsRestoration: boolean\n  onFinishNavigating: () => void\n}) {\n  /**\n   * Browsers have an API for scroll restoration. We wait for the page to load first,\n   * in case the browser is able to restore scroll position automatically, and then\n   * set it to manual mode.\n   */\n  useEffect(() => {\n    window.history.scrollRestoration = 'manual'\n  }, [])\n\n  /**\n   * If the page is reloading, allow the browser to handle its own scroll restoration.\n   */\n  useBeforeUnload(\n    useCallback(() => {\n      window.history.scrollRestoration = 'auto'\n    }, [])\n  )\n\n  useLayoutEffect(() => {\n    // The app has just loaded\n    if (isFirstLoad || !scrollNeedsRestoration) {\n      isFirstLoad = false\n      return\n    }\n\n    const position = positions[location.key]\n\n    /**\n     * When serverState gets updated, `pending` is true while the fetch is in progress.\n     * When that resolves, the serverState is updated. We should wait until the internal\n     * location pointer and serverState match, and pending is false, to do any scrolling.\n     */\n    const finishedNavigating =\n      !pending &&\n      location.pathname === serverProps.pathname &&\n      location.search === serverProps.search\n\n    if (!finishedNavigating) {\n      return\n    }\n\n    // If there is a location hash, scroll to it\n    if (location.hash) {\n      const element = document.querySelector(location.hash)\n      if (element) {\n        element.scrollIntoView()\n        onFinishNavigating()\n        return\n      }\n    }\n\n    // If we have a matching position, scroll to it\n    if (position) {\n      window.scrollTo(0, position)\n      onFinishNavigating()\n      return\n    }\n\n    // Scroll to the top of new pages\n    window.scrollTo(0, 0)\n    onFinishNavigating()\n  }, [\n    location.pathname,\n    location.search,\n    location.hash,\n    location.key,\n    pending,\n    serverProps.pathname,\n    serverProps.search,\n    scrollNeedsRestoration,\n    onFinishNavigating,\n  ])\n}\n"],
  "mappings": "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",
  "names": []
}
