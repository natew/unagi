{
  "version": 3,
  "sources": ["../../../../src/foundation/ServerRequestProvider/ServerRequestProvider.tsx"],
  "sourcesContent": ["import React, { createContext, useContext } from 'react'\n\nimport type { QueryKey } from '../../types.js'\nimport { hashKey } from '../../utilities/hash.js'\nimport { collectQueryTimings } from '../../utilities/log/index.js'\nimport { getTime } from '../../utilities/timing.js'\nimport type { UnagiRequest } from '../UnagiRequest/UnagiRequest.server.js'\n\n// Context to inject current request in SSR\nconst RequestContextSSR = createContext<UnagiRequest | null>(null)\n\n// Cache to inject current request in RSC\nfunction requestCacheRSC() {\n  return new Map()\n}\n\nrequestCacheRSC.key = Symbol.for('UNAGI_REQUEST')\n\ntype ServerRequestProviderProps = {\n  request: UnagiRequest\n  children: React.ReactNode\n}\n\nfunction getInternalReactDispatcher() {\n  return (\n    // @ts-ignore\n    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher.current || {}\n  )\n}\n\nfunction isRsc() {\n  // This flag is added by RSC Vite plugin\n  return __UNAGI_TEST__ || !!getInternalReactDispatcher().isRsc\n}\n\n// Note: use this only during RSC/Flight rendering. The React dispatcher\n// for SSR/Fizz rendering does not implement getCacheForType.\nfunction getCacheForType(resource: () => Map<any, any>) {\n  const dispatcher = getInternalReactDispatcher()\n\n  // @ts-ignore\n  if (__UNAGI_TEST__ && !dispatcher.getCacheForType) {\n    // Jest does not have access to the RSC runtime, mock it here:\n    // @ts-ignore\n    return (globalThis.__jestRscCache ??= resource())\n  }\n\n  return dispatcher.getCacheForType(resource)\n}\n\nexport function ServerRequestProvider({ request, children }: ServerRequestProviderProps) {\n  if (isRsc()) {\n    // Save the request object in a React cache that is\n    // scoped to this current rendering.\n\n    const requestCache = getCacheForType(requestCacheRSC)\n\n    requestCache.set(requestCacheRSC.key, request)\n\n    return <>{children}</>\n  }\n\n  // Use a normal provider in SSR to make the request object\n  // available in the current rendering.\n  return <RequestContextSSR.Provider value={request}>{children}</RequestContextSSR.Provider>\n}\n\nexport function useServerRequest() {\n  const request: UnagiRequest | undefined = isRsc()\n    ? getCacheForType(requestCacheRSC)?.get(requestCacheRSC.key)\n    : useContext(RequestContextSSR) // eslint-disable-line react-hooks/rules-of-hooks\n\n  if (!request) {\n    if (__UNAGI_TEST__) {\n      // Unit tests are not wrapped in ServerRequestProvider.\n      // This mocks it, instead of providing it in every test.\n      return { ctx: {} } as UnagiRequest\n    }\n\n    throw new Error('No ServerRequest Context found')\n  }\n\n  return request\n}\n\ntype RequestCacheResult<T> =\n  | { data: T; error?: never } // success\n  | { data?: never; error: Response | Error } // failure\n\n/**\n * Returns data stored in the request cache.\n * It will throw the promise if data is not ready.\n */\nexport function useRequestCacheData<T>(\n  key: QueryKey,\n  fetcher: (request: UnagiRequest) => T | Promise<T>\n): RequestCacheResult<T> {\n  const request = useServerRequest()\n  const cache = request.ctx.cache\n  const cacheKey = hashKey(key)\n\n  if (!cache.has(cacheKey)) {\n    let result: RequestCacheResult<T>\n    let promise: Promise<RequestCacheResult<T> | void>\n\n    cache.set(cacheKey, () => {\n      if (result !== undefined) {\n        collectQueryTimings(request, key, 'rendered')\n        return result\n      }\n\n      if (!promise) {\n        const startApiTime = getTime()\n        const maybePromise = fetcher(request)\n\n        if (!(maybePromise instanceof Promise)) {\n          result = { data: maybePromise }\n          return result\n        }\n\n        promise = maybePromise.then(\n          (data) => {\n            result = { data }\n\n            collectQueryTimings(request, key, 'resolved', getTime() - startApiTime)\n          },\n          (error) => (result = { error })\n        )\n      }\n\n      throw promise\n    })\n  }\n\n  // Making sure the promise has returned data because it can be initated by a preload request,\n  // otherwise, we throw the promise\n  const result = cache.get(cacheKey).call()\n  if (result instanceof Promise) throw result\n  return result as RequestCacheResult<T>\n}\n\nexport function preloadRequestCacheData(request: UnagiRequest): void {\n  const preloadQueries = request.getPreloadQueries()\n  const { cache } = request.ctx\n\n  preloadQueries?.forEach((preloadQuery, cacheKey) => {\n    collectQueryTimings(request, preloadQuery.key, 'preload')\n\n    if (!cache.has(cacheKey)) {\n      let result: unknown\n      let promise: Promise<unknown>\n\n      cache.set(cacheKey, () => {\n        if (result !== undefined) {\n          collectQueryTimings(request, preloadQuery.key, 'rendered')\n          return result\n        }\n        if (!promise) {\n          const startApiTime = getTime()\n          promise = preloadQuery.fetcher(request).then(\n            (data) => {\n              result = { data }\n              collectQueryTimings(request, preloadQuery.key, 'resolved', getTime() - startApiTime)\n            },\n            (error) => {\n              result = { error }\n            }\n          )\n        }\n        return promise\n      })\n    }\n\n    cache.get(cacheKey).call()\n  })\n}\n"],
  "mappings": "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",
  "names": []
}
