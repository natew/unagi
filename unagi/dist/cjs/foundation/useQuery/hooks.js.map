{
  "version": 3,
  "sources": ["../../../../src/foundation/useQuery/hooks.ts"],
  "sourcesContent": ["import type { CachingStrategy, PreloadOptions, QueryKey } from '../../types.js'\nimport {\n  collectQueryCacheControlHeaders,\n  collectQueryTimings,\n  getLoggerWithContext,\n} from '../../utilities/log/index.js'\nimport {\n  deleteItemFromCache,\n  generateSubRequestCacheControlHeader,\n  getItemFromCache,\n  isStale,\n  setItemInCache,\n} from '../Cache/cache-sub-request.js'\nimport { CacheShort, NO_STORE } from '../Cache/strategies/index.js'\nimport { useRequestCacheData, useServerRequest } from '../ServerRequestProvider/index.js'\nimport type { UnagiRequest } from '../UnagiRequest/UnagiRequest.server.js'\n\nexport interface UnagiUseQueryOptions {\n  /** The [caching strategy](https://shopify.dev/custom-storefronts/unagi/framework/cache#caching-strategies) to help you\n   * determine which cache control header to set.\n   */\n  cache?: CachingStrategy\n  /** Whether to [preload the query](https://shopify.dev/custom-storefronts/unagi/framework/preloaded-queries).\n   * Defaults to `false`. Specify `true` to preload the query for the URL or `'*'`\n   * to preload the query for all requests.\n   */\n  preload?: PreloadOptions\n  /** A function that inspects the response body to determine if it should be cached.\n   */\n  shouldCacheResponse?: (body: any) => boolean\n}\n\n/**\n * The `useQuery` hook executes an asynchronous operation like `fetch` in a way that\n * supports [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html). You can use this\n * hook to call any third-party APIs from a server component.\n *\n * \\> Note:\n * \\> If you're making a simple fetch call on the server, then we recommend using the [`fetchSync`](https://shopify.dev/api/unagi/hooks/global/fetchsync) hook instead.\n */\nexport function useQuery<T>(\n  /** A string or array to uniquely identify the current query. */\n  key: QueryKey,\n  /** An asynchronous query function like `fetch` which returns data. */\n  queryFn: () => Promise<T>,\n  /** The options to manage the cache behavior of the sub-request. */\n  queryOptions?: UnagiUseQueryOptions\n) {\n  const request = useServerRequest()\n  const withCacheIdKey = ['__QUERY_CACHE_ID__', ...(typeof key === 'string' ? [key] : key)]\n  const fetcher = cachedQueryFnBuilder<T>(withCacheIdKey, queryFn, queryOptions)\n\n  collectQueryTimings(request, withCacheIdKey, 'requested')\n\n  if (shouldPreloadQuery(queryOptions)) {\n    request.savePreloadQuery({\n      preload: queryOptions?.preload,\n      key: withCacheIdKey,\n      fetcher,\n    })\n  }\n\n  return useRequestCacheData<T>(withCacheIdKey, fetcher)\n}\n\nexport function shouldPreloadQuery(queryOptions?: UnagiUseQueryOptions): boolean {\n  if (!queryOptions) return true\n\n  const hasCacheOverride = typeof queryOptions?.cache?.mode !== 'undefined'\n  const hasPreloadOverride = typeof queryOptions?.preload !== 'undefined'\n  const cacheValue = queryOptions?.cache?.mode\n  const preloadValue = queryOptions?.preload\n\n  // If preload is explicitly defined, then it takes precedence\n  if (hasPreloadOverride) {\n    return !!preloadValue\n  }\n\n  return hasCacheOverride ? cacheValue !== NO_STORE : true\n}\n\nfunction cachedQueryFnBuilder<T>(\n  key: QueryKey,\n  generateNewOutput: () => Promise<T>,\n  queryOptions?: UnagiUseQueryOptions\n) {\n  const resolvedQueryOptions = {\n    ...(queryOptions ?? {}),\n  }\n\n  const shouldCacheResponse = queryOptions?.shouldCacheResponse ?? (() => true)\n\n  /**\n   * Attempt to read the query from cache. If it doesn't exist or if it's stale, regenerate it.\n   */\n  async function useCachedQueryFn(request: UnagiRequest) {\n    const log = getLoggerWithContext(request)\n\n    const cacheResponse = await getItemFromCache(key)\n\n    if (cacheResponse) {\n      const [output, response] = cacheResponse\n\n      collectQueryCacheControlHeaders(request, key, response.headers.get('cache-control'))\n\n      /**\n       * Important: Do this async\n       */\n      if (isStale(key, response)) {\n        const lockKey = ['lock', ...(typeof key === 'string' ? [key] : key)]\n\n        // Run revalidation asynchronously\n        const revalidatingPromise = getItemFromCache(lockKey).then(async (lockExists) => {\n          if (lockExists) return\n\n          await setItemInCache(\n            lockKey,\n            true,\n            CacheShort({\n              maxAge: 10,\n            })\n          )\n\n          try {\n            const output = await generateNewOutput()\n\n            if (shouldCacheResponse(output)) {\n              await setItemInCache(key, output, resolvedQueryOptions?.cache)\n            }\n          } catch (e: any) {\n            log.error(`Error generating async response: ${e.message}`)\n          } finally {\n            await deleteItemFromCache(lockKey)\n          }\n        })\n\n        // Asynchronously wait for it in workers\n        request.ctx.runtime?.waitUntil?.(revalidatingPromise)\n      }\n\n      return output\n    }\n\n    const newOutput = await generateNewOutput()\n\n    /**\n     * Important: Do this async\n     */\n    if (shouldCacheResponse(newOutput)) {\n      const setItemInCachePromise = setItemInCache(key, newOutput, resolvedQueryOptions?.cache)\n\n      request.ctx.runtime?.waitUntil?.(setItemInCachePromise)\n    }\n\n    collectQueryCacheControlHeaders(\n      request,\n      key,\n      generateSubRequestCacheControlHeader(resolvedQueryOptions?.cache)\n    )\n\n    return newOutput\n  }\n\n  return useCachedQueryFn\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,iBAIO;AACP,+BAMO;AACP,wBAAqC;AACrC,mCAAsD;AA0B/C,kBAEL,KAEA,SAEA,cACA;AACA,QAAM,UAAU,mDAAiB;AACjC,QAAM,iBAAiB,CAAC,sBAAsB,GAAI,OAAO,QAAQ,WAAW,CAAC,GAAG,IAAI,GAAI;AACxF,QAAM,UAAU,qBAAwB,gBAAgB,SAAS,YAAY;AAE7E,sCAAoB,SAAS,gBAAgB,WAAW;AAExD,MAAI,mBAAmB,YAAY,GAAG;AACpC,YAAQ,iBAAiB;AAAA,MACvB,SAAS,6CAAc;AAAA,MACvB,KAAK;AAAA,MACL;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO,sDAAuB,gBAAgB,OAAO;AACvD;AAEO,4BAA4B,cAA8C;AAjEjF;AAkEE,MAAI,CAAC;AAAc,WAAO;AAE1B,QAAM,mBAAmB,OAAO,oDAAc,UAAd,mBAAqB,UAAS;AAC9D,QAAM,qBAAqB,OAAO,8CAAc,aAAY;AAC5D,QAAM,aAAa,mDAAc,UAAd,mBAAqB;AACxC,QAAM,eAAe,6CAAc;AAGnC,MAAI,oBAAoB;AACtB,WAAO,CAAC,CAAC;AAAA,EACX;AAEA,SAAO,mBAAmB,eAAe,6BAAW;AACtD;AAEA,8BACE,KACA,mBACA,cACA;AACA,QAAM,uBAAuB;AAAA,IAC3B,GAAI,gBAAgB,CAAC;AAAA,EACvB;AAEA,QAAM,sBAAsB,8CAAc,wBAAwB,OAAM;AAKxE,kCAAgC,SAAuB;AA/FzD;AAgGI,UAAM,MAAM,qCAAqB,OAAO;AAExC,UAAM,gBAAgB,MAAM,+CAAiB,GAAG;AAEhD,QAAI,eAAe;AACjB,YAAM,CAAC,QAAQ,YAAY;AAE3B,sDAAgC,SAAS,KAAK,SAAS,QAAQ,IAAI,eAAe,CAAC;AAKnF,UAAI,sCAAQ,KAAK,QAAQ,GAAG;AAC1B,cAAM,UAAU,CAAC,QAAQ,GAAI,OAAO,QAAQ,WAAW,CAAC,GAAG,IAAI,GAAI;AAGnE,cAAM,sBAAsB,+CAAiB,OAAO,EAAE,KAAK,OAAO,eAAe;AAC/E,cAAI;AAAY;AAEhB,gBAAM,6CACJ,SACA,MACA,kCAAW;AAAA,YACT,QAAQ;AAAA,UACV,CAAC,CACH;AAEA,cAAI;AACF,kBAAM,UAAS,MAAM,kBAAkB;AAEvC,gBAAI,oBAAoB,OAAM,GAAG;AAC/B,oBAAM,6CAAe,KAAK,SAAQ,6DAAsB,KAAK;AAAA,YAC/D;AAAA,UACF,SAAS,GAAP;AACA,gBAAI,MAAM,oCAAoC,EAAE,SAAS;AAAA,UAC3D,UAAE;AACA,kBAAM,kDAAoB,OAAO;AAAA,UACnC;AAAA,QACF,CAAC;AAGD,4BAAQ,IAAI,YAAZ,mBAAqB,cAArB,4BAAiC;AAAA,MACnC;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,MAAM,kBAAkB;AAK1C,QAAI,oBAAoB,SAAS,GAAG;AAClC,YAAM,wBAAwB,6CAAe,KAAK,WAAW,6DAAsB,KAAK;AAExF,0BAAQ,IAAI,YAAZ,mBAAqB,cAArB,4BAAiC;AAAA,IACnC;AAEA,oDACE,SACA,KACA,mEAAqC,6DAAsB,KAAK,CAClE;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;",
  "names": []
}
