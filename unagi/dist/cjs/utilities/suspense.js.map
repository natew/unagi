{
  "version": 3,
  "sources": ["../../../src/utilities/suspense.ts"],
  "sourcesContent": ["import { QueryKey } from '../types.js'\nimport { hashKey } from './hash.js'\n\n/**\n * Wrap the fetch promise in a way that React Suspense understands.\n * Essentially, keep throwing something until you have legit data.\n */\nexport function wrapPromise<T>(promise: Promise<T>) {\n  let status = 'pending'\n  let response: T\n\n  const suspender = promise.then(\n    (res) => {\n      status = 'success'\n      response = res\n    },\n    (err) => {\n      status = 'error'\n      response = err\n    }\n  )\n\n  const read = () => {\n    switch (status) {\n      case 'pending':\n        throw suspender\n      case 'error':\n        throw response\n      default:\n        return response\n    }\n  }\n\n  return { read }\n}\n\ntype Await<T> = T extends Promise<infer V> ? V : never\n\ntype SuspenseCacheEntry = {\n  promise: Promise<unknown>\n  error?: any\n  response?: unknown\n}\n\nconst browserCache: Record<string, SuspenseCacheEntry> = {}\n\n/**\n * Perform an async function in a synchronous way for Suspense support.\n * To be used only in the client.\n * Inspired by https://github.com/pmndrs/suspend-react\n */\nfunction query<Fn extends () => Promise<unknown>>(key: QueryKey, fn: Fn, preload = false) {\n  const stringKey = hashKey(key)\n\n  if (browserCache[stringKey]) {\n    const entry = browserCache[stringKey]\n    if (preload) return undefined as unknown as Await<ReturnType<Fn>>\n    if (entry.error) throw entry.error\n    if (entry.response) return entry.response as Await<ReturnType<Fn>>\n    if (!preload) throw entry.promise\n  }\n\n  const entry: SuspenseCacheEntry = {\n    promise: fn()\n      .then((response) => (entry.response = response))\n      .catch((error) => (entry.error = error)),\n  }\n  browserCache[stringKey] = entry\n\n  if (!preload) throw entry.promise\n  return undefined as unknown as Await<ReturnType<Fn>>\n}\n\nexport const suspendFunction = <Fn extends () => Promise<unknown>>(key: QueryKey, fn: Fn) =>\n  query(key, fn)\nexport const preloadFunction = (key: QueryKey, fn: () => Promise<unknown>) => query(key, fn, true)\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAwB;AAMjB,qBAAwB,SAAqB;AAClD,MAAI,SAAS;AACb,MAAI;AAEJ,QAAM,YAAY,QAAQ,KACxB,CAAC,QAAQ;AACP,aAAS;AACT,eAAW;AAAA,EACb,GACA,CAAC,QAAQ;AACP,aAAS;AACT,eAAW;AAAA,EACb,CACF;AAEA,QAAM,OAAO,MAAM;AACjB,YAAQ;AAAA,WACD;AACH,cAAM;AAAA,WACH;AACH,cAAM;AAAA;AAEN,eAAO;AAAA;AAAA,EAEb;AAEA,SAAO,EAAE,KAAK;AAChB;AAUA,MAAM,eAAmD,CAAC;AAO1D,eAAkD,KAAe,IAAQ,UAAU,OAAO;AACxF,QAAM,YAAY,yBAAQ,GAAG;AAE7B,MAAI,aAAa,YAAY;AAC3B,UAAM,SAAQ,aAAa;AAC3B,QAAI;AAAS,aAAO;AACpB,QAAI,OAAM;AAAO,YAAM,OAAM;AAC7B,QAAI,OAAM;AAAU,aAAO,OAAM;AACjC,QAAI,CAAC;AAAS,YAAM,OAAM;AAAA,EAC5B;AAEA,QAAM,QAA4B;AAAA,IAChC,SAAS,GAAG,EACT,KAAK,CAAC,aAAc,MAAM,WAAW,QAAS,EAC9C,MAAM,CAAC,UAAW,MAAM,QAAQ,KAAM;AAAA,EAC3C;AACA,eAAa,aAAa;AAE1B,MAAI,CAAC;AAAS,UAAM,MAAM;AAC1B,SAAO;AACT;AAEO,MAAM,kBAAkB,CAAoC,KAAe,OAChF,MAAM,KAAK,EAAE;AACR,MAAM,kBAAkB,CAAC,KAAe,OAA+B,MAAM,KAAK,IAAI,IAAI;",
  "names": []
}
