{
  "version": 3,
  "sources": ["../../../../src/foundation/Cache/cache-sub-request.ts"],
  "sourcesContent": ["import type { AllCacheOptions, CachingStrategy, QueryKey } from '../../types.js'\nimport { hashKey } from '../../utilities/hash.js'\nimport { getCache } from '../runtime.js'\nimport * as CacheApi from './cache.js'\nimport { CacheShort } from './strategies/index.js'\n\n/**\n * Wrapper Cache functions for sub queries\n */\n\n/**\n * Cache API is weird. We just need a full URL, so we make one up.\n */\nfunction getKeyUrl(key: string) {\n  return `https://shopify.dev/?${key}`\n}\n\nfunction getCacheOption(userCacheOptions?: CachingStrategy): AllCacheOptions {\n  return userCacheOptions || CacheShort()\n}\n\nexport function generateSubRequestCacheControlHeader(userCacheOptions?: CachingStrategy): string {\n  return CacheApi.generateDefaultCacheControlHeader(getCacheOption(userCacheOptions))\n}\n\n/**\n * Get an item from the cache. If a match is found, returns a tuple\n * containing the `JSON.parse` version of the response as well\n * as the response itself so it can be checked for staleness.\n */\nexport async function getItemFromCache(key: QueryKey): Promise<undefined | [any, Response]> {\n  const cache = getCache()\n\n  if (!cache) {\n    return\n  }\n\n  const url = getKeyUrl(hashKey(key))\n  const request = new Request(url)\n\n  const response = await CacheApi.getItemFromCache(request)\n\n  if (!response) {\n    return\n  }\n\n  return [await response.json(), response]\n}\n\n/**\n * Put an item into the cache.\n */\nexport async function setItemInCache(\n  key: QueryKey,\n  value: any,\n  userCacheOptions?: CachingStrategy\n) {\n  const cache = getCache()\n  if (!cache) {\n    return\n  }\n\n  const url = getKeyUrl(hashKey(key))\n  const request = new Request(url)\n  const response = new Response(JSON.stringify(value))\n\n  await CacheApi.setItemInCache(request, response, getCacheOption(userCacheOptions))\n}\n\nexport async function deleteItemFromCache(key: QueryKey) {\n  const cache = getCache()\n  if (!cache) return\n\n  const url = getKeyUrl(hashKey(key))\n  const request = new Request(url)\n\n  await CacheApi.deleteItemFromCache(request)\n}\n\n/**\n * Manually check the response to see if it's stale.\n */\nexport function isStale(key: QueryKey, response: Response) {\n  return CacheApi.isStale(new Request(getKeyUrl(hashKey(key))), response)\n}\n"],
  "mappings": "AACA;AACA;AACA;AACA;AASA,mBAAmB,KAAa;AAC9B,SAAO,wBAAwB;AACjC;AAEA,wBAAwB,kBAAqD;AAC3E,SAAO,oBAAoB,WAAW;AACxC;AAEO,8CAA8C,kBAA4C;AAC/F,SAAO,SAAS,kCAAkC,eAAe,gBAAgB,CAAC;AACpF;AAOA,gCAAuC,KAAqD;AAC1F,QAAM,QAAQ,SAAS;AAEvB,MAAI,CAAC,OAAO;AACV;AAAA,EACF;AAEA,QAAM,MAAM,UAAU,QAAQ,GAAG,CAAC;AAClC,QAAM,UAAU,IAAI,QAAQ,GAAG;AAE/B,QAAM,WAAW,MAAM,SAAS,iBAAiB,OAAO;AAExD,MAAI,CAAC,UAAU;AACb;AAAA,EACF;AAEA,SAAO,CAAC,MAAM,SAAS,KAAK,GAAG,QAAQ;AACzC;AAKA,8BACE,KACA,OACA,kBACA;AACA,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC,OAAO;AACV;AAAA,EACF;AAEA,QAAM,MAAM,UAAU,QAAQ,GAAG,CAAC;AAClC,QAAM,UAAU,IAAI,QAAQ,GAAG;AAC/B,QAAM,WAAW,IAAI,SAAS,KAAK,UAAU,KAAK,CAAC;AAEnD,QAAM,SAAS,eAAe,SAAS,UAAU,eAAe,gBAAgB,CAAC;AACnF;AAEA,mCAA0C,KAAe;AACvD,QAAM,QAAQ,SAAS;AACvB,MAAI,CAAC;AAAO;AAEZ,QAAM,MAAM,UAAU,QAAQ,GAAG,CAAC;AAClC,QAAM,UAAU,IAAI,QAAQ,GAAG;AAE/B,QAAM,SAAS,oBAAoB,OAAO;AAC5C;AAKO,iBAAiB,KAAe,UAAoB;AACzD,SAAO,SAAS,QAAQ,IAAI,QAAQ,UAAU,QAAQ,GAAG,CAAC,CAAC,GAAG,QAAQ;AACxE;",
  "names": []
}
